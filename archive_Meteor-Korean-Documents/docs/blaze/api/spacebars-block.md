---
title: 블럭 태그
---

# 블럭 태그 %{ #spacebars-block }%

블럭 태그는 기본 제공되는 디렉티브(지시문) 또는 커스텀 블록 헬퍼를 호출하여,
디렉티브 또는 헬퍼에 의해 한 번 또는 그 이상 인스턴스화 되거나,
전혀 인스턴스화 되지 않을 수 있는 템플릿 컨텐츠 블럭을 전달합니다.

블록 태그는 특수 템플릿 태그 `{​{ else }}`로 기본 구분되는 "else" 컨텐츠를 지정할 수도 있습니다.

블록 태그의 컨텐츠는 유효한 HTML 태그로 구성되어야 합니다.

속성 값 내에 블록 태그를 사용할 수 있습니다.

## `{​{#if }} & {​{#unless }}`

- 설명: 데이터 인자 값에 따라 제공되는 컨텐츠 또는 "else" 컨텐츠를 렌더링합니다.

  빈 배열을 포함해 `null`, `undefined`, `0` 및 `false`는 "거짓" 값으로 간주되며,
  다른 값은 참으로 간주됩니다.

  `{​{#unless }}`는 단지 `{​{#if }}`와 반대로 동작합니다.

- 예제:

  ```html
  {{#if something }}
    <p>참 값입니다.</p>
  {{else}}
    <p>거짓 값입니다.</p>
  {{/if}}
  ```
  
## `{​{#with }}`

- 설명: 이 태그 범위 내 컨텐츠에 새 데이터 컨텍스트 객체를 설정합니다.
  
  `#with`는 `#if`처럼 인자로 `falsy` 값을 받으면 렌더링 되지 않습니다.
  대신 `{​{else}}`를 통해 다른 블럭을 제공할 수 있습니다.

  만약 전달 받는 인수가 문자나 숫자와 같이 비객체 값이라면,
  레핑된 객체로 변환 됩니다.
  따라서 문자열일 경우에는 `String(this)`,
  숫자일 경우 `Number(this)`와 같이 참조해 사용할 수 있습니다.

- 객체를 새 데이터 컨텍스트로 래핑하는 기본 예제:
  ```html
  <ul>
  {{#with employee }}
    <div>Name: {{ name }}</div>
    <div>Age: {{ age }}</div>
  {{/with}}
  </ul>
  ```

- 객체를 현장에서 정의하여 전달하는 예제:
  ```html
  {{#with x=1 y=2 }}
    <p>{{ someHelper }}</p>
  {{/with}}
  ```

## `{​{#each }}`

- 설명: 이것은 시퀀스를 인자로 사용하고,
  반환되는 각 항목을 해당 블럭 데이터 컨텍스트에 설정합니다. <br>
  `in` 키워드를 사용하여 현재 항목을 참조할 수 있게 하면,
  새로운 데이터 컨텍스트를 생성하지 않고,
  기존 데이터 컨텍스트에 항목을 추가하는 것입니다.

  시퀀스에 0 개의 항목이 있는 경우,
  `{​{else}}`를 사용할 수 있습니다.

  `{​{#each }}` 블럭 내에서는 `@index`라는 특별한 변수를 사용하여,
  현재 항목의 인덱스 값을 참조할 수 있습니다.

  :::info
  시퀀스란?
  
  `#each`에서 사용하는 시퀀스는 보통 Meteor의 커서이지만,
  일반적인 JS배열, `null`, `undefined` 일 수 있습니다.
  :::

- 새로운 데이터 컨텍스트 블럭으로 사용하는 예제:
  ```html
  <ul>
    {{#each people }}
      <li>{{ name }}</li>
    {{/each}}
  </ul>
  ```

- 기존 데이터 컨텍스트와 함께 사용하는 얘제:
  ```html
  <ul>
    {{#each person in people }}
      <li>{{ person.name }}</li>
    {{/each}}
  </ul>
  ```

### `each` 문법에서 반응성 모델에 관하여 %{ #reactivity-model-for-Each }%

`each` 인자가 변경될 때, DOM은 항상 새로운 시퀀스를 반영하도록 업데이트 됩니다.
하지만 인자가 컬렉션 커서인 경우 시퀀스는 고유 ID(_id)로 식별 가능한 문서들이므로,
쿼리가 변경되지 않아 커서 자체가 유지되는한,
커서의 내용이 변경됨에 따라 DOM이 어떻게 업데이트 되는지에 대해 추론하는 것은 쉽습니다.
각 문서의 렌더링된 내용은 문서가 커서에 있는 동안 유지되며,
문서가 다시 정렬되면 DOM이 다시 정렬됩니다.

하지만 `each`의 인자가 서로 다른 커서 객체 또는 반응형 일반 JS 객체의 배열일 경우,
`each`의 구현은 너무 많은 비용이 들지 않도록 아래와 같은 전략을 시도합니다.

1. `_id` 필드가 있는 객체의 경우, 해당 필드를 식별 키로 사용합니다.
2. `_id` 필드가 없는 객체의 경우 배열 인덱스를 식별 키로 사용합니다. <br>
   이 경우, 1번 방법보다는 느리지만 3번 방법보다는 빠릅니다.
3. 숫자 또는 문자열 값을 식별 값으로 사용합니다.

중복되는 식별 키의 경우 첫 번째 키 이후의 모든 중복 키는 임의의 키로 대체됩니다.
`_id` 필드가 고유한 객체를 사용하는 것이 렌더링된 엘리먼트를 온전히 제어할 수 있는 방법입니다.

## `{​{#let }}`

- 설명: 지정된 블럭 내에 새 명칭의 변수를 만듭니다.
  데이터 컨텍스트는 변경되지 않지만,
  템플릿 내에서 단축형으로 표현식을 참조할 수 있습니다.

- 예제:
  ```html
  {{#let name=person.bio.firstName color=generateColor}}
    <div>{{name}}이(가) {{color}} 카드를 얻었다!</div>
  {{/let}}
  ```

## `{​{! }}` & ## `{​{!--  --}}` 주석 ${ #comment }$

- 설명: 이 주석태그는 탬플릿에서는 주석이지만,
  HTML에서 랜더링 되지 않습니다.

- 한 줄 주석 예제:
  ```html
  {{! 이것은 Blaze의 한 줄 주석입니다. }}
  <div class="section">
    ...
  </div>
  ```

- 다중 주석 예제:
  ```html
  {{!-- 이것은 Blaze의 다중문 주석입니다.
  이곳에 {{ foo }}와 같은 표기를 해도 무방합니다.
  {{#with x}}이것 역시 주석으로 처리됩니다.{{/with}}
  --}}
  ```

## 커스텀 블럭 핼퍼 ${ #custom-block-helpers }$

- 설명: 커스텀 블럭 헬퍼를 정의하려면 템플릿을 선언한 다음 `{​{> someTemplate }}`가 아닌,
  `{​{#someTemplate}}`를 사용하여 호출하면 됩니다.

  템플릿이 블럭 헬퍼로 호출되면,
  템플릿 내부에서 `{​{> Template.contentBlock }}`과 `{​{> Template.elseBlock }}`을 사용하여,
  전달된 블럭 컨텐츠를 사용할 수 있습니다.

- 예제:

  컨텐츠를 `div`로 감싼 간단한 템플릿
  ```html
  <template name="note">
    <div class="note">
      {{> Template.contentBlock}}
    </div>
  </template>
  ```
  
  아래와 같이 호출
  ```html
  {{#note}}
    아무 컨텐츠나 이곳에 넣으면 됩니다.
  {{/note}}
  ```

- `#unless`를 `#if`로 구현한 예제:
  ```html
  <template name="unless">
    {{#if this}}
      {{> Template.elseBlock}}
    {{else}}
      {{> Template.contentBlock}}
    {{/if}}
  </template>
  ```

  `unless`는 기본 지원됩니다.
  여기서 `this`는 `#if`로 전달된 데이터 컨텍스트(인자) 입니다.
  따라서 커스텀 템플릿을 감싼 `#each`나 `#with`의 데이터 컨텍스트는 포함되지 않습니다.

  `{​{> Template.contentBlock }}` 또는 `{​{> Template.elseBlock }}`에 인자를 전달하여,
  원하는 데이터 컨텍스트를 호출할 수 있습니다. <br>
  `{​{#if Template.contentBlock }}`으로 현재 블럭 템플릿이 아닌 블럭 헬퍼로 호출되었는지 확인할 수도 있습니다.